<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Command Line Applications in Rust</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/special-content.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">快速上手</a></li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">1.</strong> 通过 15 分钟写一个命令行应用来学习 Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/setup.html"><strong aria-hidden="true">1.1.</strong> 项目设置</a></li><li class="chapter-item expanded "><a href="tutorial/cli-args.html"><strong aria-hidden="true">1.2.</strong> 解析命令行参数</a></li><li class="chapter-item expanded "><a href="tutorial/impl-draft.html"><strong aria-hidden="true">1.3.</strong> grrs 的第一个实现</a></li><li class="chapter-item expanded "><a href="tutorial/errors.html"><strong aria-hidden="true">1.4.</strong> 更好的错误处理</a></li><li class="chapter-item expanded "><a href="tutorial/output.html"><strong aria-hidden="true">1.5.</strong> 输出</a></li><li class="chapter-item expanded "><a href="tutorial/testing.html"><strong aria-hidden="true">1.6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="tutorial/packaging.html"><strong aria-hidden="true">1.7.</strong> Packaging and distributing a Rust tool</a></li></ol></li><li class="chapter-item expanded "><a href="in-depth/index.html"><strong aria-hidden="true">2.</strong> In-depth topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="in-depth/signals.html"><strong aria-hidden="true">2.1.</strong> Signal handling</a></li><li class="chapter-item expanded "><a href="in-depth/config-files.html"><strong aria-hidden="true">2.2.</strong> Using config files</a></li><li class="chapter-item expanded "><a href="in-depth/exit-code.html"><strong aria-hidden="true">2.3.</strong> Exit codes</a></li><li class="chapter-item expanded "><a href="in-depth/human-communication.html"><strong aria-hidden="true">2.4.</strong> Communicating with humans</a></li><li class="chapter-item expanded "><a href="in-depth/machine-communication.html"><strong aria-hidden="true">2.5.</strong> Communicating with machines</a></li><li class="chapter-item expanded "><a href="in-depth/docs.html"><strong aria-hidden="true">2.6.</strong> Rendering documentation for your CLI apps</a></li></ol></li><li class="chapter-item expanded "><a href="resources/index.html"><strong aria-hidden="true">3.</strong> Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Command Line Applications in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ulivz/rust-cli-zh_CN" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-中的命令行界面程序"><a class="header" href="#rust-中的命令行界面程序">Rust 中的命令行界面程序</a></h1>
<p>Rust 是一种静态编译、执行速度快的语言，拥有出色的工具和快速发展的生态系统，
这使得它非常适合编写命令行界面（Command Line Interface，下文简称 CLI）程序:
一个 CLI 应该小巧、便携且运行迅速。
编写 CLI 也是开始学习 Rust 的好方法，欢迎将 Rust 介绍给你的团队！</p>
<p>编写简单的 CLI 对于刚接触该语言并想要感受它的初学者来说是一个很好的练习，
然而，这个话题有很多东西，往往只是在（练习）很久以后才会浮现出来。</p>
<p>这本书的结构是这样的：
我们会从一个快速教程开始，之后你会得到一个可以跑起来的 CLI 工具。
你将接触到 Rust 的一些核心概念以及 CLI 应用程序的主要知识，
接下来的章节将更详细地介绍其中的一些知识。</p>
<p>在我们深入 CLI 应用程序之前的最后一件事：
如果你在本书中发现翻译错误，或希望帮助我们更新来自 <a href="https://github.com/rust-cli/book">英文原版</a> 的翻译，
你可以在 <a href="https://github.com/ins-x/rust-cli-book-cn">Github</a> 中找到它的源代码。
我们很想听听你的反馈！谢谢！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通过-15-分钟写一个命令行应用来学习-rust"><a class="header" href="#通过-15-分钟写一个命令行应用来学习-rust">通过 15 分钟写一个命令行应用来学习 Rust</a></h1>
<p>本教程将会引导你使用 <a href="https://rust-lang.org/">Rust</a> 写一个 CLI (command line interface) 应用，
大约需要十五分钟达到让你有一个正在运行的程序的地步，
在那之后，我们将继续调整我们的程序，
直到我们可以发布我们的小工具。</p>
<p>你将学习有关如何开始的所有要领，
以及在哪里可以找到更多信息。
你可以随意跳过现在不需要知道的部分，
或随时返回阅读。</p>
<aside>
<p><strong>先决条件:</strong>
本教程不会取代对编程的一般介绍，
同时希望您熟悉一些常见的概念。
你应该对使用命令行/终端感到满意。
如果您已经了解其他几种语言，
这可能是第一次接触 Rust 的好机会。</p>
<p><strong>寻求帮助:</strong>
如果您在任何时候对所使用的功能感到不知所措或感到困惑，
请查看 Rust 随附的大量官方文档，
首先是《The Rust Programming Language》一书。 它带有大多数 Rust 安装（rustup doc）的知识，可在 <a href="https://doc.rust-lang.org">doc.rust-lang.org</a> 上在线获取。</p>
<p>也非常欢迎你提问——
Rust 社区以友好和乐于助人而著称。
看看 <a href="https://www.rust-lang.org/community">community page</a>
查看人们讨论 Rust 的地方列表。</p>
</aside>
<p>你想写什么样的项目？ 
我们从简单的事情开始怎么样：
让我们写一个小 <code>grep</code> 克隆。 
这是一个我们可以提供字符串和路径的工具，
它只会打印包含给定字符串的行。
我们称它为 <code>grrs</code>（发音为 “grass”）。</p>
<p>最后，我们希望能够像这样运行我们的工具：</p>
<pre><code class="language-console">$ cat test.txt
foo: 10
bar: 20
baz: 30
$ grrs foo test.txt
foo: 10
$ grrs --help
[some help text explaining the available options]
</code></pre>
<aside class="note">
<p><strong>Note:</strong>
这本书是为 <a href="https://doc.rust-lang.org/edition-guide/index.html">Rust 2018</a> 编写的。
代码示例也可用于 Rust 2015，
但你可能需要稍微调整一下；
例如，添加 <code>extern crate foo;</code> 调用。</p>
<p>确保你运行 Rust 1.31.0（或更高版本）
并且您在 <code>Cargo.toml</code> 文件的 <code>[package]</code> 中设置了 <code>edition = &quot;2018&quot;</code></p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目设置"><a class="header" href="#项目设置">项目设置</a></h1>
<p>如果你还没有准备好，
首先在你的电脑上<a href="https://www.rust-lang.org/tools/install">安装 Rust</a>
（这可能会耗费几分钟），
接着，打开 Terminal，进入你想要放置应用代码的项目目录。</p>
<p>通过在目录中运行 <code>cargo new grrs</code> 来初始化一个项目，
如果你查看这个被创建的 <code>grrs</code> 目录，
你将会发现对于一个 Rust 项目需要的典型的设置：</p>
<ul>
<li><code>Cargo.toml</code> 文件包含了当前项目的元信息
包含了我们用到的 <code>dependencies</code>、<code>external</code> 的库的青岛。</li>
<li><code>src/main.rs</code> 文件，是当前项目的入口文件。</li>
</ul>
<p>如果你在 <code>grrs</code> 目录中运行 <code>cargo run</code>，
你将会得到一个 “Hello World”，至此，你的项目准备好了。</p>
<h2 id="可能的运行过程"><a class="header" href="#可能的运行过程">可能的运行过程</a></h2>
<pre><code class="language-console">$ cargo new grrs
     Created binary (application) `grrs` package
$ cd grrs/
$ cargo run
   Compiling grrs v0.1.0 (/Users/pascal/code/grrs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `target/debug/grrs`
Hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="解析命令行参数"><a class="header" href="#解析命令行参数">解析命令行参数</a></h1>
<p>一个典型的调用我们的 CLI 工具的方式如下：</p>
<pre><code class="language-console">$ grrs foobar test.txt
</code></pre>
<p>我们期望我们的程序去查找 <code>test.txt</code>
并打印那些包含 <code>foobar</code> 的行，
那么我们如何拿到这两个值呢？</p>
<p>在 CLI Program 名称之后的文本通常被称为 <code>command-line arguments</code>
或者 <code>command-line flags</code> (通常长这样: <code>--this</code>)，
操作系统内部通常将它们认为是一些字符串的清单 —— 粗略地说，这些字符串被空格分开。</p>
<p>这里有好几种方式去思考 arguments，
以及如何将它们解析成某种利用使用的形式。
你也需要去告诉你的 CLI Program 的用户有哪些可以传递的 arguments，
以及这些 arguments 所期望的格式。</p>
<h2 id="获取-cli-参数"><a class="header" href="#获取-cli-参数">获取 CLI 参数</a></h2>
<p>标准库中包含了一个函数 <a href="https://doc.rust-lang.org/1.39.0/std/env/fn.args.html"><code>std::env::args()</code></a>, 
为你提供了一个用于获取指定的 arguments 的 <a href="https://doc.rust-lang.org/1.39.0/std/iter/index.html">iterator</a>，
第一个入口 (索引为 <code>0</code>) 将会是你的 CLI Program 的名称 (如 <code>grrs</code>)，
接下来的部分则是用户写的。</p>
<p>以这种方式获取原始的 arguments 非常容易（在文件 <code>src/main.rs</code> 中 <code>fn main() {</code> 之后）</p>
<pre><code class="language-rust ignore">let pattern = std::env::args().nth(1).expect(&quot;no pattern given&quot;);
let path = std::env::args().nth(2).expect(&quot;no path given&quot;);
println!(&quot;pattern: {}&quot;, pattern);
println!(&quot;path: {}&quot;, path);
</code></pre>
<p>使用 <code>cargo run -- pattern path</code> 测试输出:</p>
<pre><code class="language-console">$ cargo run -- pattern path
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
     Running `target/debug/grrs pattern path`
pattern: pattern
path: path
</code></pre>
<h2 id="给-cli-arguments-增加类型"><a class="header" href="#给-cli-arguments-增加类型">给 CLI arguments 增加类型</a></h2>
<p>让我们把 CLI arguments 视为一个表示你的程序输入的自定义数据类型，
而不是想象成一堆文本，
这通常是值得的。</p>
<p>让我们看 <code>grrs foobar test.txt</code>:
这里有两个 <code>arguments</code>：
第一个是 <code>pattern</code>（要查找的字符串）,
接着第二个是 <code>path</code>（要搜索的文件）.</p>
<p>关于 CLI arguments 我们还需要说哪些东西吗？
好吧，首先，两者都是必须的，
我们还没有谈及任何默认值，
所以我们希望我们的用户总是提供两个值。
因此，我们可以说一下这些参数的类型：
<code>pattern</code> 应该是一个字符串，
而第二个参数 <code>path</code> 应该是一个文件的路径。</p>
<p>在 Rust 中，围绕所处理的数据来组织程序是非常常见的，
所以这种查看 CLI 参数的方式非常合理。
让我们从这里开始（在文件 <code>src/main.rs</code> 中 <code>fn main() {</code> 之前）:</p>
<pre><code class="language-rust ignore">struct Cli {
    pattern: String,
    path: std::path::PathBuf,
}

</code></pre>
<p>这里定义了一个新的结构（一个 <a href="https://doc.rust-lang.org/1.39.0/book/ch05-00-structs.html"><code>struct</code></a>），
它包含了两个字段 <code>pattern</code>、<code>path</code> 来存储数据。</p>
<aside>
<p><strong>Note:</strong>
<a href="https://doc.rust-lang.org/1.39.0/std/path/struct.PathBuf.html"><code>PathBuf</code></a> 与 <a href="https://doc.rust-lang.org/1.39.0/std/string/struct.String.html"><code>String</code></a> 类似，但是（设计上）是为了跨平台工作的路径。</p>
</aside>
<p>现在，我们仍然需要将 Program 的实际参数转换为这种形式。
一种方式是手动解析我们从操作系统拿到的字符串列表，然后自己构建这个结构，可能是这样：</p>
<pre><code class="language-rust ignore">let pattern = std::env::args().nth(1).expect(&quot;no pattern given&quot;);
let path = std::env::args().nth(2).expect(&quot;no path given&quot;);
println!(&quot;pattern: {}&quot;, pattern);
println!(&quot;path: {}&quot;, path);
let args = Cli {
    pattern: pattern,
    path: std::path::PathBuf::from(path),
};
</code></pre>
<p>这可以工作，但是不太方便，
你将如何去处理 <code>--pattern=&quot;foo&quot;</code> 或  <code>--pattern &quot;foo&quot;</code> 的需求呢？
你会如何去实现 <code>--help</code>?</p>
<h2 id="使用-clap-解析-cli-参数"><a class="header" href="#使用-clap-解析-cli-参数">使用 Clap 解析 CLI 参数</a></h2>
<p>一个更棒的方式是去使用众多可用的库的一个，
在 Rust 生态中，解析命令行参数最流行的库叫作 <a href="https://docs.rs/clap/"><code>clap</code></a>，
它拥有你期望的所有能力，
包括对 Sub Command、<a href="https://docs.rs/clap_complete/">Shell completion</a> 还有好的 Help 信息的支持。</p>
<p>首先，让我们通过在 <code>Cargo.toml</code> 的 <code>[dependencies]</code> 中
增加 <code>clap = { version = &quot;4.0&quot;, features = [&quot;derive&quot;] }</code> 
来引入 <code>clap</code>。</p>
<p>现在，我们可以在代码中写 <code>use clap::Parser;</code> 了，
并在我们的 <code>struct Cli</code> 上方增加 <code>#[derive(Parser)]</code>，
同时，让我们在这个过程中也写一些注释。</p>
<p>代码最终会像这样（在文件 <code>src/main.rs</code> 中 <code>fn main() {</code> 之前)：</p>
<pre><code class="language-rust ignore">use clap::Parser;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(Parser)]
struct Cli {
    /// The pattern to look for
    pattern: String,
    /// The path to the file to read
    path: std::path::PathBuf,
}
</code></pre>
<aside class="node">
<p><strong>注意：</strong>
你可以将许多自定义的属性添加到字段中，
举例来说，
如果您想将此字段用于 <code>-o</code> 或 <code>--output</code> 之后的参数，
你可以增加 <code>#[arg(short = 'o', long = &quot;output&quot;)]</code>，
想要了解更多信息，
请移步 <a href="https://docs.rs/clap/">clap 的文档</a>。</p>
</aside>
<p>在 <code>Cli</code> struct 的正下方，我们的模板包含它的 <code>main</code> 函数。
当程序启动时，它会调用这个函数，
其第一行是：</p>
<pre><code class="language-rust ignore">fn main() {
    let args = Cli::parse();
}
</code></pre>
<p>这将尝试将命令行参数解析到我们的 <code>Cli</code> struct 中。</p>
<p>但如果失败了怎么办？
这就是这种方法的美妙之处：
Clap 知道可以哪些字段期望出现，
以及它们的预期格式是什么。
它可以自动生成一个友好的 <code>--help</code> 消息，
以及给出一些不错的错误信息，
并在你输入 <code>--putput</code> 时建议你传入 <code>--output</code>。</p>
<aside class="note">
<p><strong>注意：</strong>
<code>parse</code> 方法是在你的 <code>main</code> 函数中使用的。
失败时，
它会打印出错误或帮助信息，
并立即退出程序，
请不要在其他地方使用！</p>
</aside>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h2>
<p>你的代码现在应该长这样：</p>
<pre><code class="language-rust ignore">#![allow(unused)]

use clap::Parser;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(Parser)]
struct Cli {
    /// The pattern to look for
    pattern: String,
    /// The path to the file to read
    path: std::path::PathBuf,
}

fn main() {
    let args = Cli::parse();
}
</code></pre>
<p>如果不带任何参数运行它：</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 10.16s
     Running `target/debug/grrs`
error: The following required arguments were not provided:
    &lt;pattern&gt;
    &lt;path&gt;

USAGE:
    grrs &lt;pattern&gt; &lt;path&gt;

For more information try --help
</code></pre>
<p>我们可以在使用 <code>cargo run</code> 时直接通过在 <code>--</code> 后面写参数来传递参数：</p>
<pre><code class="language-console">$ cargo run -- some-pattern some-file
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
     Running `target/debug/grrs some-pattern some-file`
</code></pre>
<p>如你看到的，
没有输出。
这是对的 ——
这只是意味着没有错误，我们的程序结束了。</p>
<aside class="exercise">
<p><strong>读者练习:</strong>
让这个程序输出它的参数！</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grrs-的第一个实现"><a class="header" href="#grrs-的第一个实现"><em>grrs</em> 的第一个实现</a></h1>
<p>在关于命令行参数的一章后，
我们已经有了输入数据，
我们可以开始编写实际的工具了，
现在，我们的 <code>main</code> 函数只包含这一行：</p>
<pre><code class="language-rust ignore">    let args = Cli::parse();
</code></pre>
<p>让我们从读取我们得到的文件开始：</p>
<pre><code class="language-rust ignore">    let content = std::fs::read_to_string(&amp;args.path).expect(&quot;could not read file&quot;);
</code></pre>
<aside>
<p><strong>注意：</strong>
看到这里的 <a href="https://doc.rust-lang.org/1.39.0/std/result/enum.Result.html#method.expect"><code>.expect</code></a> 方法了吗？
这是一个当这个值（这个 case 中是这个输入文件）无法被读取时能够使程序立即退出的快捷功能，
看起来不是很漂亮，
在下一章<a href="tutorial/./errors.html">更好的错误报告</a>中，
我们将研究如何改进这一点。</p>
</aside>
<p>现在，让我们遍历这些行，
并打印初满足我们（指定的）pattern 的每一行：</p>
<pre><code class="language-rust ignore">    for line in content.lines() {
        if line.contains(&amp;args.pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
</code></pre>
<h2 id="包装起来"><a class="header" href="#包装起来">包装起来</a></h2>
<p>你的代码现在应该如下所示：</p>
<pre><code class="language-rust ignore">#![allow(unused)]

use clap::Parser;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(Parser)]
struct Cli {
    /// The pattern to look for
    pattern: String,
    /// The path to the file to read
    path: std::path::PathBuf,
}

fn main() {
    let args = Cli::parse();
    let content = std::fs::read_to_string(&amp;args.path).expect(&quot;could not read file&quot;);

    for line in content.lines() {
        if line.contains(&amp;args.pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
}
</code></pre>
<p>试试运行 <code>cargo run -- main src/main.rs</code>，它现在应该可以工作！</p>
<aside class="exercise">
<p><strong>读者练习：</strong>
这不是最好的实现：
无论文件有多大，
它都将整个文件读入内存,
让我们想想办法优化
（一个可能的思路是使用 <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufReader.html"><code>BufReader</code></a>，而不是 <code>read_to_string()</code>）。</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="更好的错误处理"><a class="header" href="#更好的错误处理">更好的错误处理</a></h1>
<p>我们都只能接受会发生错误的现实，
与很多其他语言相比，
在使用 Rust 时，很难不去注意和处理这个现实。
因为没有例外，
所有可能的错误状态通常都编码在函数的返回类型中。</p>
<h2 id="results"><a class="header" href="#results">Results</a></h2>
<p>像 <a href="https://doc.rust-lang.org/1.39.0/std/fs/fn.read_to_string.html"><code>read_to_string</code></a> 这样的函数不会返回字符串，
相反，它返回一个 <a href="https://doc.rust-lang.org/1.39.0/std/result/index.html"><code>Result</code></a>，
其中包含一个 <code>String</code>，
或者某种类型的错误，
（在这个 case 中是  <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>std::io::Error</code></a>）。</p>
<p>你该如何知道这些错误是哪个呢？
由于 <code>Result</code> 是一个 <code>enum</code> (枚举)，
你可以使用 <code>match</code> 来检查它是哪个变体（<code>variant</code>）：</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::fs::read_to_string(&quot;test.txt&quot;);
match result {
    Ok(content) =&gt; { println!(&quot;File content: {}&quot;, content); }
    Err(error) =&gt; { println!(&quot;Oh noes: {}&quot;, error); }
}
<span class="boring">}
</span></code></pre></pre>
<aside>
<p><strong>注意:</strong>
如果你不确定在 Rust 中的 <code>enums</code> 是什么，以及是如何工作的？
<a href="https://doc.rust-lang.org/1.39.0/book/ch06-00-enums.html">请移步 Rust Handbook 的这一章节</a>
赶上进度。</p>
</aside>
<h2 id="unwrapping"><a class="header" href="#unwrapping">Unwrapping</a></h2>
<p>现在，我们能够访问文件的内容了，
但是在 <code>match</code> block 之后我们真的不能用它做任何事，
为此，我们需要以某种方式来处理错误情，
这里的挑战在于，<code>match</code> block 的所有分支都必须返回类型相同的东西，
但是这里有一个巧妙的技巧可以解决这一问题：</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::fs::read_to_string(&quot;test.txt&quot;);
let content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { panic!(&quot;Can't deal with {}, just exit here&quot;, error); }
};
println!(&quot;file content: {}&quot;, content);
<span class="boring">}
</span></code></pre></pre>
<p>我们可以使用在 match block 之后的 <code>content</code> 中的 String，
如果 <code>result</code> 是一个错误，这个 String 将不会存在，
但是由于程序会在运行到我们使用 <code>content</code> 的位置之前就会退出，
所以没关系。</p>
<aside>
</aside>
<p>这可能看起来有点粗暴，
但是很方便。
如果你的程序需要去访问去访问一个文件，同时在这个文件不存在时不做任何事，
退出程序是有个有效的策略，
在 <code>Results</code> 中甚至有一个快捷方法 <code>unwrap</code> 能够直接完成这件事：</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let content = std::fs::read_to_string(&quot;test.txt&quot;).unwrap();
<span class="boring">}
</span></code></pre></pre>
<h2 id="无需-panic"><a class="header" href="#无需-panic">无需 panic</a></h2>
<p>当然，中断程序不是处理错误的唯一方式，
除了 <code>panic!</code>，我们也可以简单地书写 <code>return</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span>let result = std::fs::read_to_string(&quot;test.txt&quot;);
let content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { return Err(error.into()); }
};
println!(&quot;file content: {}&quot;, content);
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>然而，这改变我们的函数所需要的返回值类型，
事实上，我们的示例中一种隐藏着一些东西：
即函数签名在代码中的位置，
在上一个有 <code>return</code> 的示例中，
它变得很重要，
这里是 <em>完整</em> 的例子：</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let result = std::fs::read_to_string(&quot;test.txt&quot;);
    let content = match result {
        Ok(content) =&gt; { content },
        Err(error) =&gt; { return Err(error.into()); }
    };
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre></pre>
<p>我们返回值是一个 <code>Result</code>!
这也是我们为什么可以在 <code>match</code> block 的第二个分支写 <code>return Err(error);</code>。
有看到最底部有一个 <code>Ok(())</code> 吗？
这是这个函数的默认的函数返回值，
同时意味着 “Result 是 OK 的，以及没有内容”。</p>
<aside>
<p><strong>注意:</strong>
为什么这里没有写成 <code>return Ok(());</code> 这样?
这很容易 —— 也是完全有效的。
在 Rust 中最后一个任意的表达式都是函数的返回值，
并且在习惯上省略掉不必要的 <code>return</code>。</p>
</aside>
<h2 id="question-mark"><a class="header" href="#question-mark">Question Mark</a></h2>
<p>和调用 <code>.unwrap()</code> 是一个 shortcut 方法一样，
对于错误分支中包含有 <code>panic!</code> 的 <code>match</code>，
对于错误分支的 <code>return</code> 的 <code>match</code>，
我们有另一个 shortcut: <code>?</code></p>
<p>没错，一个问号，
你可以将这个操作符插在一个类型为 <code>Result</code> 的值之后，
接着 Rust 将在内部展开成某种和我们写的
<code>match</code> 很相似的东西。</p>
<p>让我们尝试一下：</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let content = std::fs::read_to_string(&quot;test.txt&quot;)?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre></pre>
<p>非常简洁！</p>
<aside>
<p><strong>注意:</strong>
这里还有一些事情发生，
不需要理解就可以使用它，
举例来说，
在 <code>main</code> 函数中的错误类型是 <code>Box&lt;dyn std::error::Error&gt;</code>，
但是我们看到上述的 <code>read_to_string</code> 返回了一个 <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>std::io::Error</code></a>，
这里能够工作，是因为 <code>?</code> 展开的代码中 <em>转换</em> 了错误类型。</p>
<p><code>Box&lt;dyn std::error::Error&gt;</code> 同时也是一个非常有趣的类型，
这是一个 Box，可以包含 <em>任意</em>
的实现了标准的 <a href="tutorial/%60std::error::Error%60"><code>Error</code></a> trait 的类型
这意味着基本上所有的错误都可以被放置在这个 box 中，
所以我们可以使用 <code>?</code> 在所有返回 <code>Result</code> 的常用函数中使用 <code>?</code>。</p>
</aside>
<h2 id="providing-context"><a class="header" href="#providing-context">Providing Context</a></h2>
<p>当在你的 <code>main</code> 函数中使用 <code>?</code> 出现错误是正常，
但这并不太好，
举例来说，
当你运行 <code>std::fs::read_to_string(&quot;test.txt&quot;)?</code> 时，
但是文件 <code>test.txt</code> 又不存在，
你将会获得这样的输出：</p>
<pre><code class="language-text">Error: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</code></pre>
<p>在这种情况下，你的代码没有字面上包含文件名，
因此想要告诉用户哪个文件 <code>NotFound</code> 会很困难，
这里有好几种方式去解决这个问题。</p>
<p>举例来说，我们可以创建我们自己的错误类型，
接着使用它来构建一个自定义的错误信息：</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
struct CustomError(String);

fn main() -&gt; Result&lt;(), CustomError&gt; {
    let path = &quot;test.txt&quot;;
    let content = std::fs::read_to_string(path)
        .map_err(|err| CustomError(format!(&quot;Error reading `{}`: {}&quot;, path, err)))?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre>
<p>现在，
运行代码我们会得到我们的自定义的错误信息：</p>
<pre><code class="language-text">Error: CustomError(&quot;Error reading `test.txt`: No such file or directory (os error 2)&quot;)
</code></pre>
<p>看起来不是很漂亮，
但是我们稍后可以非常轻松地为我们的输出调整调试的输出。</p>
<p>这种模式其实非常常见，
但是它存在一个问题：
我们没有存储原始的错误，
只有它的字符串标识。
一个经常被使用的库 <a href="https://docs.rs/anyhow"><code>anyhow</code></a> 对这个问题有一个巧妙的解决方案：
和我们使用 <code>CustomError</code> 类似，
其 <a href="https://docs.rs/anyhow/1.0/anyhow/trait.Context.html"><code>Context</code></a> trait 可以在使用时增加一个 description，
此外，它也保留了原始错误，
所以我们得到了一个指出根本原因的错误信息的 “chain”。</p>
<p>首先，让我们通过在 <code>Cargo.toml</code> 的 <code>[dependencies]</code> 中
增加 <code>anyhow = &quot;1.0&quot;</code> 来引入 <code>anyhow</code>。</p>
<p>完整的 example 看起来是这样：</p>
<pre><code class="language-rust ignore">use anyhow::{Context, Result};

fn main() -&gt; Result&lt;()&gt; {
    let path = &quot;test.txt&quot;;
    let content = std::fs::read_to_string(path)
        .with_context(|| format!(&quot;could not read file `{}`&quot;, path))?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre>
<p>将会打印出一个错误：</p>
<pre><code class="language-text">Error: could not read file `test.txt`

Caused by:
    No such file or directory (os error 2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输出"><a class="header" href="#输出">输出</a></h1>
<h2 id="打印-hello-world"><a class="header" href="#打印-hello-world">打印 “Hello World”</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello World&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>好吧，这很容易，
Great，让我们进入下一个主题。</p>
<h2 id="使用-println"><a class="header" href="#使用-println">使用 println</a></h2>
<p>你可以使用 <code>println!</code> macro 来打印几乎所有的东西。
这个 macro 有一些非常赞的能力，
但也需要写一些特别的语法。
它期望你能够写一个字符串文本作为第一个参数，
其中包含一些占位符，
这些占位符将会被接下来的 arguments 的值所填充。</p>
<p>举个例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
println!(&quot;My lucky number is {}.&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>将会打印出：</p>
<pre><code class="language-console">My lucky number is 42.
</code></pre>
<p>上面的字符串中的大括号（<code>{}</code>）便是其中的占位符之一，
这是默认的占位符类型，
它尝试以人类可读的方式来打印给定的值。
但并非所有的类型都可以做到这一点，
这也是为什么还有一个 “调试标识”，
你可以通过填充占位符的大括号来实现，就像这样：<code>{:?}</code>。</p>
<p>举例来说：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs = vec![1, 2, 3];
println!(&quot;The list is: {:?}&quot;, xs);
<span class="boring">}
</span></code></pre></pre>
<p>会打印出：</p>
<pre><code class="language-console">The list is: [1, 2, 3]
</code></pre>
<p>如果你期望你的数据类型可以被打印用于调试或者日出输出，
在大多数情况下，你可以在其定义上方增加 <code>#[derive(Debug)]</code>。</p>
<aside>
<p><strong>注意:</strong>
“用户友好的” 打印是使用 <a href="https://doc.rust-lang.org/1.39.0/std/fmt/trait.Display.html"><code>Display</code></a> trait，
调试输出使用 <a href="https://doc.rust-lang.org/1.39.0/std/fmt/trait.Debug.html"><code>Debug</code></a> trait（人类可读，但是是面向开发者的），
关于更多你可以在 <code>println!</code> 中使用的语法的信息，
你可以在 [<code>std::fmt</code> 的文档] 找到。</p>
</aside>
<h2 id="打印错误"><a class="header" href="#打印错误">打印错误</a></h2>
<p>打印错误应当通过 <code>stderr</code> 来完成，
能够更加容易地将它们通过管道传输到文件或者更多工具中。</p>
<aside>
<p><strong>Tip：</strong>
在大多数操作系统中，
一个程序可以写到两个输出流中，
On most operating systems， <code>stdout</code> 和 <code>stderr</code>。
<code>stdout</code> 是程序的实际输出，
而 <code>stdout</code> 允许错误，还有其他信息能够与 <code>stdout</code> 分开，
这样的话，
输出可以被存储到一个文件或者通过管道传输到另一个程序中，
而错误可以被展示给用户。</p>
</aside>
<p>在 Rust 中，这是通过
<code>println!</code> 和 <code>eprintln!</code> 实现的，
前者打印到 <code>stdout</code>，
而后者输出到 <code>stderr</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;This is information&quot;);
eprintln!(&quot;This is an error! :(&quot;);
<span class="boring">}
</span></code></pre></pre>
<aside>
<p><strong>请留意</strong>: 打印 <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">escape codes</a> 可能会非常危险，
它会使用户的 Terminal 进入一个奇怪的状态，
手动打印时请务必非常小心！</p>
<p>理想情况下，处理原始的 escape codes 时，
你应该使用一个类似 <code>ansi_term</code> 的 crate，
来让你（还有你的用户）的生活更轻松。</p>
</aside>
<h2 id="关于-printing-的性能说明"><a class="header" href="#关于-printing-的性能说明">关于 printing 的性能说明</a></h2>
<p>打印信息到 Terminal 是出奇地慢！
如果你在一个循环中调用类似 <code>println!</code> 的方法，
它很容易成为一个原本很快的程序的瓶颈。
为了提升速度，
你有两件事可以做：</p>
<p>首先，
你可能期望减少实际 “flush” 到终端的写入次数。
（在调用）<code>println</code> 时，<em>每次</em> 都会告诉操作系统刷新到终端，
因为打印到每一个新行是非常常见的， 
如果你不需要这样做，
你可以将你的 <code>stdout</code> 句柄包装在一个 <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufWriter.html"><code>BufWriter</code></a> 里，
默认情况下，最多可以缓冲 8kb，
(当你想要立即打印的时候，
你仍然可以在这个 <code>BufWriter</code> 上调用 <code>.flush()</code>。)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = io::BufWriter::new(stdout); // optional: wrap that handle in a buffer
writeln!(handle, &quot;foo: {}&quot;, 42); // add `?` if you care about errors here
<span class="boring">}
</span></code></pre></pre>
<p>第二，
这有助于获得对 <code>stdout</code> (或 <code>stderr</code>) 的锁定，
并使用 <code>writeln!</code> 直接打印到他们。
这可以避免系统一遍又一遍地锁定和解锁 <code>stdout</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = stdout.lock(); // acquire a lock on it
writeln!(handle, &quot;foo: {}&quot;, 42); // add `?` if you care about errors here
<span class="boring">}
</span></code></pre></pre>
<p>你也可以结合这两种方法。</p>
<h2 id="展示一个-progress-bar"><a class="header" href="#展示一个-progress-bar">展示一个 progress bar</a></h2>
<p>一些 CLI 应用运行小于一秒，
其他的一些可能花费几分钟或者几小时。
如果你正在编写后一种类型的程序，
你可能想要向用户展示正在发生的事情，
为了达到这一目的，你应该打印出一些有用的状态更新，
理想的情况下，是一个易于消费的结构。</p>
<p>使用 <a href="https://crates.io/crates/indicatif">indicatif</a> crate，
你可以为你的程序添加 progress bar，
以及小的 spinners，
这里有一个简单的示例：</p>
<pre><code class="language-rust ignore">fn main() {
    let pb = indicatif::ProgressBar::new(100);
    for i in 0..100 {
        do_hard_work();
        pb.println(format!(&quot;[+] finished #{}&quot;, i));
        pb.inc(1);
    }
    pb.finish_with_message(&quot;done&quot;);
}
</code></pre>
<p>想了解更多信息，
请查看 <code>indicatif</code> 的 <a href="https://docs.rs/indicatif">文档</a> 和 <a href="https://github.com/mitsuhiko/indicatif/tree/master/examples">示例</a>。</p>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>为了更容易理解我们的程序中发生的事情，
我们可能想添加一些日志（Logging）语句。
这在编写应用程序时通常很容易，
但是半年后再次运行这个程序时，它会变得非常有用。</p>
<p>在某些方面，
日志记录与使用 <code>println!</code> 相同，
除了你可以指定消息的重要性。
通常可以使用的级别是 <em>error</em>、<em>warn</em>、<em>info</em>、<em>debug</em> 和 <em>trace</em>
（<em>error</em> 具有最高优先级，<em>trace</em> 最低）。</p>
<p>要将简单的日志记录添加到你的应用程序，
你需要两件事：
<a href="https://crates.io/crates/log">log</a> crate（包含以日志级别命名的宏）
和一个 <em>adapter</em>，它实际上会将日志输出写入有用的地方。
能够使用日志适配器（将会让程序）非常灵活：
例如，您可以使用它们不仅将日志写入终端
也可以到 <a href="https://en.wikipedia.org/wiki/Syslog">syslog</a> 或者一个中心的日志服务器。</p>
<p>由于我们现在只关心编写 CLI 应用程序，
因此（我们会建议你使用）<a href="https://crates.io/crates/env_logger">env_logger</a> ，这是一个易于使用的适配器。
它被称为 “env” 记录器，
因为你可以通过环境变量来指定应用程序打印哪些部分
（以及你要在哪个级别记录它们）。
它将在您的日志消息前面加上时间戳，
以及日志消息来自的模块。
由于库也可以使用 <code>log</code>，
你也可以轻松配置他们的日志输出。</p>
<p>这里有一个简单的示例：</p>
<pre><code class="language-rust ignore">use log::{info, warn};

fn main() {
    env_logger::init();
    info!(&quot;starting up&quot;);
    warn!(&quot;oops, nothing implemented!&quot;);
}
</code></pre>
<p>假设你在 Linux 和 macOS 上有一个名为 <code>src/bin/output-log.rs</code> 的文件，
你可以像这样运行它：</p>
<pre><code class="language-console">$ env RUST_LOG=info cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>在 Windows 的 PowerShell 里, 你可以这样运行：</p>
<pre><code class="language-console">$ $env:RUST_LOG=&quot;info&quot;
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>在 Windows 的 CMD 里, 你可以这样运行：</p>
<pre><code class="language-console">$ set RUST_LOG=info
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p><code>RUST_LOG</code> 是环境变量的名称，
你可以使用它来设置您的日志设置。
<code>env_logger</code> 还包含一个构建器，
因此你可以通过编程的方式来调整这些设置，
并且，例如，默认情况下还显示 <em>info</em> 级别的消息。</p>
<p>这里有很多可供选择的日志适配器，
以及 <code>log</code> 的替代或者扩展。
如果你知道您的应用程序需要记录很多日志，
请确保对它们进行 Review，
并使你的用户的生活更轻松。</p>
<aside>
<p><strong>Tip:</strong>
经验表明，即使是不太有用的 CLI 程序最终也可能会被使用多年
（特别是如果它们是作为临时解决方案），
如果你的应用程序不起作用，
并且有人（例如，将来的你）想要弄清楚为什么，
是都支持传递 <code>--verbose</code> 以获得额外的日志输出，
可以会产生几分钟或者几小时的调试时间的差异。
在 <a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a> crate 中包含了一个快速的方法，
它使用 <code>clap</code> 将 <code>--verbose</code> 添加到项目中。</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Over decades of software development,
people have discovered one truth:
Untested software rarely works.
(Many people would go as far as saying:
“Most tested software doesn’t work either.”
But we are all optimists here, right?)
So, to ensure that your program does what you expect it to do,
it is wise to test it.</p>
<p>One easy way to do that is
to write a <code>README</code> file
that describes what your program should do.
And when you feel ready to make a new release,
go through the <code>README</code> and ensure that
the behavior is still as expected.
You can make this a more rigorous exercise
by also writing down how your program should react to erroneous inputs.</p>
<p>Here’s another fancy idea:
Write that <code>README</code> before you write the code.</p>
<aside>
<p><strong>Aside:</strong>
Have a look at
<a href="https://en.wikipedia.org/wiki/Test-driven_development">test-driven development</a> (TDD)
if you haven’t heard of it.</p>
</aside>
<h2 id="automated-testing"><a class="header" href="#automated-testing">Automated testing</a></h2>
<p>Now, this is all fine and dandy,
but doing all of this manually?
That can take a lot of time.
At the same time,
many people have come to enjoy telling computers to do things for them.
Let’s talk about how to automate these tests.</p>
<p>Rust has a built-in test framework,
so let’s start by writing a first test:</p>
<pre><code class="language-rust ignore">#[test]
fn check_answer_validity() {
    assert_eq!(answer(), 42);
}
</code></pre>
<p>You can put this snippet of code in pretty much any file
and <code>cargo test</code> will find
and run it.
The key here is the <code>#[test]</code> attribute.
It allows the build system to discover such functions
and run them as tests,
verifying that they don’t panic.</p>
<aside class="exercise">
<p><strong>Exercise for the reader:</strong>
Make this test work.</p>
<p>You should end up with output like the following:</p>
<pre><code class="language-text">running 1 test
test check_answer_validity ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
</aside>
<p>Now that we’ve seen <em>how</em> we can write tests,
we still need to figure out <em>what</em> to test.
As you’ve seen it’s fairly easy to write assertions
for functions.
But a CLI application is often more than one function!
Worse, it often deals with user input,
reads files,
and writes output.</p>
<h2 id="making-your-code-testable"><a class="header" href="#making-your-code-testable">Making your code testable</a></h2>
<p>There are two complementary approaches to testing functionality:
Testing the small units that you build your complete application from,
these are called “unit tests”.
There is also testing the final application “from the outside”
called “black box tests” or “integration tests”.
Let’s begin with the first one.</p>
<p>To figure out what we should test,
let’s see what our program features are.
Mainly, <code>grrs</code> is supposed to print out the lines that match a given pattern.
So, let’s write unit tests for <em>exactly this</em>:
We want to ensure that our most important piece of logic works,
and we want to do it in a way that is not dependent
on any of the setup code we have around it
(that deals with CLI arguments, for example).</p>
<p>Going back to our <a href="tutorial/impl-draft.html">first implementation</a> of <code>grrs</code>,
we added this block of code to the <code>main</code> function:</p>
<pre><code class="language-rust ignore">// ...
for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!(&quot;{}&quot;, line);
    }
}
</code></pre>
<p>Sadly, this is not very easy to test.
First of all, it’s in the main function, so we can’t easily call it.
This is easily fixed by moving this piece of code into a function:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_matches(content: &amp;str, pattern: &amp;str) {
    for line in content.lines() {
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we can call this function in our test,
and see what its output is:</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    find_matches(&quot;lorem ipsum\ndolor sit amet&quot;, &quot;lorem&quot;);
    assert_eq!( // uhhhh
</code></pre>
<p>Or… can we?
Right now, <code>find_matches</code> prints directly to <code>stdout</code>, i.e., the terminal.
We can’t easily capture this in a test!
This is a problem that often comes up
when writing tests after the implementation:
We have written a function that is firmly integrated
in the context it is used in.</p>
<aside class="note">
<p><strong>Note:</strong>
This is totally fine when writing small CLI applications.
There’s no need to make everything testable!
It is important to think about
which parts of your code you might want to write unit tests for, however.
While we’ll see that it’s easy to change this function to be testable,
this is not always the case.</p>
</aside>
<p>Alright, how can we make this testable?
We’ll need to capture the output somehow.
Rust’s standard library has some neat abstractions
for dealing with I/O (input/output)
and we’ll make use of one called <a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html"><code>std::io::Write</code></a>.
This is a <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">trait</a> that abstracts over things we can write to,
which includes strings but also <code>stdout</code>.</p>
<p>If this is the first time you’ve heard “trait”
in the context of Rust,
you are in for a treat.
Traits are one of the most powerful features of Rust.
You can think of them like interfaces in Java,
or type classes in Haskell
(whatever you are more familiar with).
They allow you to abstract over behavior
that can be shared by different types.
Code that uses traits can
express ideas in very generic and flexible ways.
This means it can also get difficult to read, though.
Don’t let that intimidate you:
Even people who have used Rust for years
don’t always get what generic code does immediately.
In that case,
it helps to think of concrete uses.
For example,
in our case,
the behavior that we abstract over is “write to it”.
Examples for the types that implement (“impl”) it
include:
The terminal’s standard output,
files,
a buffer in memory,
or TCP network connections.
(Scroll down in the <a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html">documentation for <code>std::io::Write</code></a>
to see a list of “Implementors”.)</p>
<p>With that knowledge,
let’s change our function to accept a third parameter.
It should be of any type that implements <code>Write</code>.
This way,
we can then supply a simple string
in our tests
and make assertions on it.
Here is how we can write this version of <code>find_matches</code>:</p>
<pre><code class="language-rust ignore">fn find_matches(content: &amp;str, pattern: &amp;str, mut writer: impl std::io::Write) {
    for line in content.lines() {
        if line.contains(pattern) {
            writeln!(writer, &quot;{}&quot;, line);
        }
    }
}
</code></pre>
<p>The new parameter is <code>mut writer</code>,
i.e., a mutable thing we call “writer”.
Its type is <code>impl std::io::Write</code>,
which you can read as
“a placeholder for any type that implements the <code>Write</code> trait”.
Also note how we
replaced the <code>println!(…)</code>
we used earlier
with <code>writeln!(writer, …)</code>.
<code>println!</code> works the same as <code>writeln!</code>
but always uses standard output.</p>
<p>Now we can test for the output:</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    let mut result = Vec::new();
    find_matches(&quot;lorem ipsum\ndolor sit amet&quot;, &quot;lorem&quot;, &amp;mut result);
    assert_eq!(result, b&quot;lorem ipsum\n&quot;);
}
</code></pre>
<p>To now use this in our application code,
we have to change the call to <code>find_matches</code> in <code>main</code>
by adding <a href="https://doc.rust-lang.org/1.39.0/std/io/fn.stdout.html"><code>&amp;mut std::io::stdout()</code></a> as the third parameter.
Here’s an example of a main function
that builds on what we’ve seen in the previous chapters
and uses our extracted <code>find_matches</code> function:</p>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;()&gt; {
    let args = Cli::parse();
    let content = std::fs::read_to_string(&amp;args.path)
        .with_context(|| format!(&quot;could not read file `{}`&quot;, args.path.display()))?;

    find_matches(&amp;content, &amp;args.pattern, &amp;mut std::io::stdout());

    Ok(())
}
</code></pre>
<aside class="note">
<p><strong>Note:</strong>
Since <code>stdout</code> expects bytes (not strings),
we use <code>std::io::Write</code> instead of <code>std::fmt::Write</code>.
As a result,
we give an empty vector as “writer” in our tests
(its type will be inferred to <code>Vec&lt;u8&gt;</code>),
in the <code>assert_eq!</code> we use a <code>b&quot;foo&quot;</code>.
(The <code>b</code> prefix makes this a <em>byte string literal</em>
so its type is going to be <code>&amp;[u8]</code> instead of <code>&amp;str</code>).</p>
</aside>
<aside class="note">
<p><strong>Note:</strong>
We could also make this function return a <code>String</code>,
but that would change its behavior.
Instead of writing to the terminal directly,
it would then collect everything into a string,
and dump all the results in one go at the end.</p>
</aside>
<aside class="exercise">
<p><strong>Exercise for the reader:</strong>
<a href="https://doc.rust-lang.org/1.39.0/std/macro.writeln.html"><code>writeln!</code></a> returns an <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>io::Result</code></a>
because writing can fail,
for example when the buffer is full and cannot be expanded.
Add error handling to <code>find_matches</code>.</p>
</aside>
<p>We’ve just seen how to make this piece of code easily testable.
We have</p>
<ol>
<li>identified one of the core pieces of our application,</li>
<li>put it into its own function,</li>
<li>and made it more flexible.</li>
</ol>
<p>Even though the goal was to make it testable,
the result we ended up with
is actually a very idiomatic and reusable piece of Rust code.
That’s awesome!</p>
<h2 id="splitting-your-code-into-library-and-binary-targets"><a class="header" href="#splitting-your-code-into-library-and-binary-targets">Splitting your code into library and binary targets</a></h2>
<p>We can do one more thing here.
So far we’ve put everything we wrote into the <code>src/main.rs</code> file.
This means our current project produces a single binary.
But we can also make our code available as a library, like this:</p>
<ol>
<li>Put the <code>find_matches</code> function into a new <code>src/lib.rs</code>.</li>
<li>Add a <code>pub</code> in front of the <code>fn</code> (so it’s <code>pub fn find_matches</code>)
to make it something that users of our library can access.</li>
<li>Remove <code>find_matches</code> from <code>src/main.rs</code>.</li>
<li>In the <code>fn main</code>, prepend the call to <code>find_matches</code> with <code>grrs::</code>,
so it’s now <code>grrs::find_matches(…)</code>.
This means it uses the function from the library we just wrote!</li>
</ol>
<p>The way Rust deals with projects is quite flexible
and it’s a good idea to think about
what to put into the library part of your crate early on.
You can for example think about writing a library
for your application-specific logic first
and then use it in your CLI just like any other library.
Or, if your project has multiple binaries,
you can put the common functionality into the library part of that crate.</p>
<aside class="note">
<p><strong>Note:</strong>
Speaking of putting everything into a <code>src/main.rs</code>:
If we continue to do that,
it’ll become difficult to read.
The <a href="https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">module system</a> can help you structure and organize your code.</p>
</aside>
<h2 id="testing-cli-applications-by-running-them"><a class="header" href="#testing-cli-applications-by-running-them">Testing CLI applications by running them</a></h2>
<p>Thus far, we’ve gone out of our way
to test the <em>business logic</em> of our application,
which turned out to be the <code>find_matches</code> function.
This is very valuable
and is a great first step
towards a well-tested code base.
(Usually, these kinds of tests are called “unit tests”.)</p>
<p>There is a lot of code we aren’t testing, though:
Everything that we wrote to deal with the outside world!
Imagine you wrote the main function,
but accidentally left in a hard-coded string
instead of using the argument of the user-supplied path.
We should write tests for that, too!
(This level of testing is often called
“integration testing”, or “system testing”.)</p>
<p>At its core,
we are still writing functions
and annotating them with <code>#[test]</code>.
It’s just a matter of what we do inside these functions.
For example, we’ll want to use the main binary of our project,
and run it like a regular program.
We will also put these tests into a new file in a new directory:
<code>tests/cli.rs</code>.</p>
<aside>
<p><strong>Aside:</strong>
By convention,
<code>cargo</code> will look for integration tests in the <code>tests/</code> directory.
Similarly,
it will look for benchmarks in <code>benches/</code>,
and examples in <code>examples/</code>.
These conventions also extend to your main source code:
libraries have a <code>src/lib.rs</code> file,
the main binary is <code>src/main.rs</code>,
or, if there are multiple binaries,
cargo expects them to be in <code>src/bin/&lt;name&gt;.rs</code>.
Following these conventions will make your code base more discoverable
by people used to reading Rust code.</p>
</aside>
<p>To recall,
<code>grrs</code> is a small tool that searches for a string in a file.
We have previously tested that we can find a match.
Let’s think about what other functionality we can test.</p>
<p>Here is what I came up with.</p>
<ul>
<li>What happens when the file doesn’t exist?</li>
<li>What is the output when there is no match?</li>
<li>Does our program exit with an error when we forget one (or both) arguments?</li>
</ul>
<p>These are all valid test cases.
Additionally,
we should also include one test case
for the “happy path”,
i.e., we found at least one match
and we print it.</p>
<p>To make these kinds of tests easier,
we’re going to use the <a href="https://docs.rs/assert_cmd"><code>assert_cmd</code></a> crate.
It has a bunch of neat helpers
that allow us to run our main binary
and see how it behaves.
Further,
we’ll also add the <a href="https://docs.rs/predicates"><code>predicates</code></a> crate
which helps us write assertions
that <code>assert_cmd</code> can test against
(and that have great error messages).
We’ll add those dependencies not to the main list,
but to a “dev dependencies” section in our <code>Cargo.toml</code>.
They are only required when developing the crate,
not when using it.</p>
<pre><code class="language-toml">[dev-dependencies]
assert_cmd = &quot;2.0&quot;
predicates = &quot;2.1&quot;
</code></pre>
<p>This sounds like a lot of setup.
Nevertheless –
let’s dive right in
and create our <code>tests/cli.rs</code> file:</p>
<pre><code class="language-rust ignore">use assert_cmd::prelude::*; // Add methods on commands
use predicates::prelude::*; // Used for writing assertions
use std::process::Command; // Run programs

#[test]
fn file_doesnt_exist() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut cmd = Command::cargo_bin(&quot;grrs&quot;)?;

    cmd.arg(&quot;foobar&quot;).arg(&quot;test/file/doesnt/exist&quot;);
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains(&quot;could not read file&quot;));

    Ok(())
}
</code></pre>
<p>You can run this test with
<code>cargo test</code>,
just the tests we wrote above.
It might take a little longer the first time,
as <code>Command::cargo_bin(&quot;grrs&quot;)</code> needs to compile your main binary.</p>
<h2 id="generating-test-files"><a class="header" href="#generating-test-files">Generating test files</a></h2>
<p>The test we’ve just seen only checks that our program writes an error message
when the input file doesn’t exist.
That’s an important test to have,
but maybe not the most important one:
Let’s now test that we will actually print the matches we found in a file!</p>
<p>We’ll need to have a file whose content we know,
so that we can know what our program <em>should</em> return
and check this expectation in our code.
One idea might be to add a file to the project with custom content
and use that in our tests.
Another would be to create temporary files in our tests.
For this tutorial,
we’ll have a look at the latter approach.
Mainly, because it is more flexible and will also work in other cases;
for example, when you are testing programs that change the files.</p>
<p>To create these temporary files,
we’ll be using the <a href="https://docs.rs/assert_fs"><code>assert_fs</code></a> crate.
Let’s add it to the <code>dev-dependencies</code> in our <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">assert_fs = &quot;1.0&quot;
</code></pre>
<p>Here is a new test case
(that you can write below the other one)
that first creates a temp file
(a “named” one so we can get its path),
fills it with some text,
and then runs our program
to see if we get the correct output.
When the <code>file</code> goes out of scope
(at the end of the function),
the actual temporary file will automatically get deleted.</p>
<pre><code class="language-rust ignore">use assert_fs::prelude::*;

#[test]
fn find_content_in_file() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let file = assert_fs::NamedTempFile::new(&quot;sample.txt&quot;)?;
    file.write_str(&quot;A test\nActual content\nMore content\nAnother test&quot;)?;

    let mut cmd = Command::cargo_bin(&quot;grrs&quot;)?;
    cmd.arg(&quot;test&quot;).arg(file.path());
    cmd.assert()
        .success()
        .stdout(predicate::str::contains(&quot;test\nAnother test&quot;));

    Ok(())
}
</code></pre>
<aside class="exercise">
<p><strong>Exercise for the reader:</strong>
Add integration tests for passing an empty string as pattern.
Adjust the program as needed.</p>
</aside>
<h2 id="what-to-test"><a class="header" href="#what-to-test">What to test?</a></h2>
<p>While it can certainly be fun to write integration tests,
it will also take some time to write them,
as well as to update them when your application’s behavior changes.
To make sure you use your time wisely,
you should ask yourself what you should test.</p>
<p>In general it’s a good idea to write integration tests
for all types of behavior that a user can observe.
That means that you don’t need to cover all edge cases:
It usually suffices to have examples for the different types
and rely on unit tests to cover the edge cases.</p>
<p>It is also a good idea not to focus your tests on things you can’t actively control.
It would be a bad idea to test the exact layout of <code>--help</code>
as it is generated for you.
Instead, you might just want to check that certain elements are present.</p>
<p>Depending on the nature of your program,
you can also try to add more testing techniques.
For example,
if you have extracted parts of your program
and find yourself writing a lot of example cases as unit tests
while trying to come up with all the edge cases,
you should look into <a href="https://docs.rs/proptest"><code>proptest</code></a>.
If you have a program which consumes arbitrary files and parses them,
try to write a <a href="https://rust-fuzz.github.io/book/introduction.html">fuzzer</a> to find bugs in edge cases.</p>
<aside>
<p><strong>Aside:</strong>
You can find the full, runnable source code used in this chapter
<a href="https://github.com/rust-cli/book/tree/master/src/tutorial/testing">in this book’s repository</a>.</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packaging-and-distributing-a-rust-tool"><a class="header" href="#packaging-and-distributing-a-rust-tool">Packaging and distributing a Rust tool</a></h1>
<p>If you feel confident that your program is ready for other people to use,
it is time to package and release it!</p>
<p>There are a few approaches,
and we’ll look at three of them
from “quickest to set up” to “most convenient for users”.</p>
<h2 id="quickest-cargo-publish"><a class="header" href="#quickest-cargo-publish">Quickest: <code>cargo publish</code></a></h2>
<p>The easiest way to publish your app is with cargo.
Do you remember how we added external dependencies to our project?
Cargo downloaded them from its default “crate registry”, <a href="https://crates.io/">crates.io</a>.
With <code>cargo publish</code>,
you too can publish crates to <a href="https://crates.io/">crates.io</a>.
And this works for all crates,
including those with binary targets.</p>
<p>Publishing a crate to <a href="https://crates.io/">crates.io</a> is pretty straightforward:
If you haven’t already, create an account on <a href="https://crates.io/">crates.io</a>.
Currently, this is done via authorizing you on GitHub,
so you’ll need to have a GitHub account
(and be logged in there).
Next, you log in using cargo on your local machine.
For that, go to your
<a href="https://crates.io/me">crates.io account page</a>,
create a new token,
and then run <code>cargo login &lt;your-new-token&gt;</code>.
You only need to do this once per computer.
You can learn more about this
in cargo’s <a href="https://doc.rust-lang.org/1.39.0/cargo/reference/publishing.html">publishing guide</a>.</p>
<p>Now that cargo as well as crates.io know you,
you are ready to publish crates.
Before you hastily go ahead and publish a new crate (version),
it’s a good idea to open your <code>Cargo.toml</code> once more
and make sure you added the necessary metadata.
You can find all the possible fields you can set
in the documentation for <a href="https://doc.rust-lang.org/1.39.0/cargo/reference/manifest.html">cargo’s manifest format</a>.
Here’s a quick overview of some common entries:</p>
<pre><code class="language-toml">[package]
name = &quot;grrs&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;your@email.com&gt;&quot;]
license = &quot;MIT OR Apache-2.0&quot;
description = &quot;A tool to search files&quot;
readme = &quot;README.md&quot;
homepage = &quot;https://github.com/you/grrs&quot;
repository = &quot;https://github.com/you/grrs&quot;
keywords = [&quot;cli&quot;, &quot;search&quot;, &quot;demo&quot;]
categories = [&quot;command-line-utilities&quot;]
</code></pre>
<aside class="note">
<p><strong>Note:</strong>
This example includes the mandatory license field
with a common choice for Rust projects:
The same license that is also used for the compiler itself.
It also refers to a <code>README.md</code> file.
It should include a quick description of what your project is about,
and will be included not only on the crates.io page of your crate,
but also what GitHub shows by default on repository pages.</p>
</aside>
<h3 id="how-to-install-a-binary-from-cratesio"><a class="header" href="#how-to-install-a-binary-from-cratesio">How to install a binary from crates.io</a></h3>
<p>We’ve seen how to publish a crate to crates.io,
and you might be wondering how to install it.
In contrast to libraries,
which cargo will download and compile for you
when you run <code>cargo build</code> (or a similar command),
you’ll need to tell it to explicitly install binaries.</p>
<p>This is done using
<code>cargo install &lt;crate-name&gt;</code>.
It will by default download the crate,
compile all the binary targets it contains
(in “release” mode, so it might take a while)
and copy them into the <code>~/.cargo/bin/</code> directory.
(Make sure that your shell knows to look there for binaries!)</p>
<p>It’s also possible to
install crates from git repositories,
only install specific binaries of a crate,
and specify an alternative directory to install them to.
Have a look at <code>cargo install --help</code> for details.</p>
<h3 id="when-to-use-it"><a class="header" href="#when-to-use-it">When to use it</a></h3>
<p><code>cargo install</code> is a simple way to install a binary crate.
It’s very convenient for Rust developers to use,
but has some significant downsides:
Since it will always compile your source from scratch,
users of your tool will need to have
Rust, cargo, and all other system dependencies your project requires
to be installed on their machine.
Compiling large Rust codebases can also take some time.</p>
<p>It’s best to use this for distributing tools
that are targeted at other Rust developers.
For example:
A lot of cargo subcommands
like <code>cargo-tree</code> or <code>cargo-outdated</code>
can be installed with it.</p>
<h2 id="distributing-binaries"><a class="header" href="#distributing-binaries">Distributing binaries</a></h2>
<p>Rust is a language that compiles to native code
and by default statically links all dependencies.
When you run <code>cargo build</code>
on your project that contains a binary called <code>grrs</code>,
you’ll end up with a binary file called <code>grrs</code>.
Try it out:
Using <code>cargo build</code>, it’ll be <code>target/debug/grrs</code>,
and when you run <code>cargo build --release</code>, it’ll be <code>target/release/grrs</code>.
Unless you use crates
that explicitly need external libraries to be installed on the target system
(like using the system’s version of OpenSSL),
this binary will only depend on common system libraries.
That means,
you take that one file,
send it to people running the same operating system as you,
and they’ll be able to run it.</p>
<p>This is already very powerful!
It works around two of the downsides we just saw for <code>cargo install</code>:
There is no need to have Rust installed on the user’s machine,
and instead of it taking a minute to compile,
they can instantly run the binary.</p>
<p>So, as we’ve seen,
<code>cargo build</code> <em>already</em> builds binaries for us.
The only issue is,
those are not guaranteed to work on all platforms.
If you run <code>cargo build</code> on your Windows machine,
you won’t get a binary that works on a Mac by default.
Is there a way to generate these binaries
for all the interesting platforms
automatically?</p>
<h3 id="building-binary-releases-on-ci"><a class="header" href="#building-binary-releases-on-ci">Building binary releases on CI</a></h3>
<p>If your tool is open sourced
and hosted on GitHub,
it’s quite easy to set up a free CI (continuous integration) service
like <a href="https://travis-ci.com/">Travis CI</a>.
(There are other services that also work on other platforms, but Travis is very popular.)
This basically runs setup commands
in a virtual machine
each time you push changes to your repository.
What those commands are,
and the types of machines they run on,
is configurable.
For example:
A good idea is to run <code>cargo test</code>
on a machine with Rust and some common build tools installed.
If this fails,
you know there are issues in the most recent changes.</p>
<p>We can also use this
to build binaries and upload them to GitHub!
Indeed, if we run
<code>cargo build --release</code>
and upload the binary somewhere,
we should be all set, right?
Not quite.
We still need to make sure the binaries we build
are compatible with as many systems as possible.
For example,
on Linux we can compile not for the current system,
but instead for the <code>x86_64-unknown-linux-musl</code> target,
to not depend on default system libraries.
On macOS, we can set <code>MACOSX_DEPLOYMENT_TARGET</code> to <code>10.7</code>
to only depend on system features present in versions 10.7 and older.</p>
<p>You can see one example of building binaries using this approach
<a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91">here</a> for Linux and macOS
and <a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml">here</a> for Windows (using AppVeyor).</p>
<p>Another way is to use pre-built (Docker) images
that contain all the tools we need
to build binaries.
This allows us to easily target more exotic platforms, too.
The <a href="https://github.com/japaric/trust">trust</a> project contains
scripts that you can include in your project
as well as instructions on how to set this up.
It also includes support for Windows using AppVeyor.</p>
<p>If you’d rather set this up locally
and generate the release files on your own machine,
still have a look at trust.
It uses <a href="https://github.com/rust-embedded/cross">cross</a> internally,
which works similar to cargo
but forwards commands to a cargo process inside a Docker container.
The definitions of the images are also available in
<a href="https://github.com/rust-embedded/cross">cross’ repository</a>.</p>
<h3 id="how-to-install-these-binaries"><a class="header" href="#how-to-install-these-binaries">How to install these binaries</a></h3>
<p>You point your users to your release page
that might look something <a href="https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1">like this one</a>,
and they can download the artifacts we’ve just created.
The release artifacts we’ve just generated are nothing special:
At the end, they are just archive files that contain our binaries!
This means that users of your tool
can download them with their browser,
extract them (often happens automatically),
and copy the binaries to a place they like.</p>
<p>This does require some experience with manually “installing” programs,
so you want to add a section to your README file
on how to install this program.</p>
<aside class="note">
<p><strong>Note:</strong>
If you used <a href="https://github.com/japaric/trust">trust</a> to build your binaries and added them to GitHub releases,
you can also tell people to run
<code>curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git your-name/repo-name</code>
if you think that makes it easier.</p>
</aside>
<h3 id="when-to-use-it-1"><a class="header" href="#when-to-use-it-1">When to use it</a></h3>
<p>Having binary releases is a good idea in general,
there’s hardly any downside to it.
It does not solve the problem of users having to manually
install and update
your tools,
but they can quickly get the latest releases version
without the need to install Rust.</p>
<h3 id="what-to-package-in-addition-to-your-binaries"><a class="header" href="#what-to-package-in-addition-to-your-binaries">What to package in addition to your binaries</a></h3>
<p>Right now,
when a user downloads our release builds,
they will get a <code>.tar.gz</code> file
that only contains binary files.
So, in our example project,
they will just get a single <code>grrs</code> file they can run.
But there are some more files we already have in our repository
that they might want to have.
The README file that tells them how to use this tool,
and the license file(s),
for example.
Since we already have them,
they are easy to add.</p>
<p>There are some more interesting files
that make sense especially for command-line tools,
though:
How about we also ship a man page in addition to that README file,
and config files that add completions of the possible flags to your shell?
You can write these by hand,
but <em>clap</em>, the argument parsing library we use
(which clap builds upon)
has a way to generate all these files for us.
See <a href="tutorial/../in-depth/docs.html">this in-depth chapter</a>
for more details.</p>
<h2 id="getting-your-app-into-package-repositories"><a class="header" href="#getting-your-app-into-package-repositories">Getting your app into package repositories</a></h2>
<p>Both approaches we’ve seen so far
are not how you typically install software on your machine.
Especially command-line tools
you install using global package managers
on most operating systems.
The advantages for users are quite obvious:
There is no need to think about how to install your program,
if it can be installed the same way as they install the other tools.
These package managers also allow users to update their programs
when a new version is available.</p>
<p>Sadly, supporting different systems means
you’ll have to look at how these different systems work.
For some,
it might be as easy as adding a file to your repository
(e.g. adding a Formula file like <a href="https://github.com/BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/ripgrep-bin.rb">this</a> for macOS’s <code>brew</code>),
but for others you’ll often need to send in patches yourself
and add your tool to their repositories.
There are helpful tools like
<a href="https://crates.io/crates/cargo-bundle">cargo-bundle</a>,
<a href="https://crates.io/crates/cargo-deb">cargo-deb</a>, and
<a href="https://crates.io/crates/cargo-aur">cargo-aur</a>,
but describing how they work
and how to correctly package your tool
for those different systems is beyond the scope of this chapter.</p>
<p>Instead,
let’s have a look at a tool that is written in Rust
and that is available in many different package managers.</p>
<h3 id="an-example-ripgrep"><a class="header" href="#an-example-ripgrep">An example: ripgrep</a></h3>
<p><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> is an alternative to <code>grep</code>/<code>ack</code>/<code>ag</code> and is written in Rust.
It’s quite successful and is packaged for many operating systems:
Just look at <a href="https://github.com/BurntSushi/ripgrep/tree/31adff6f3c4bfefc9e77df40871f2989443e6827#installation">the “Installation” section</a> of its README!</p>
<p>Note that it lists a few different options how you can install it:
It starts with a link to the GitHub releases
which contain the binaries so you can download them directly;
then it lists how to install it using a bunch of different package managers;
finally, you can also install it using <code>cargo install</code>.</p>
<p>This seems like a very good idea:
Don’t pick and choose one of the approaches presented here,
but start with <code>cargo install</code>,
add binary releases,
and finally start distributing your tool using system package managers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="in-depth-topics"><a class="header" href="#in-depth-topics">In-depth topics</a></h1>
<p>A small collection of chapters covering some more details
that you might care about when writing your command line application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signal-handling"><a class="header" href="#signal-handling">Signal handling</a></h1>
<p>Processes
like command line applications
need to react to signals sent by the operating system.
The most common example is probably <kbd>Ctrl</kbd>+<kbd>C</kbd>,
the signal that typically tells a process to terminate.
To handle signals in Rust programs
you need to consider how you can receive these signals
as well as how you can react to them.</p>
<aside>
<p><strong>Note:</strong>
If your applications does not need to gracefully shutdown,
the default handling is fine
(i.e. exit immediately
and let the OS cleanup resources like open file handles).
In that case:
No need to do what this chapter tells you!</p>
<p>However,
for applications that need to clean up after themselves,
this chapter is very relevant!
For example,
if your application needs to
properly close network connections
(saying “good bye” to the processes at the other end),
remove temporary files,
or reset system settings,
read on.</p>
</aside>
<h2 id="differences-between-operating-systems"><a class="header" href="#differences-between-operating-systems">Differences between operating systems</a></h2>
<p>On Unix systems
(like Linux, macOS, and FreeBSD)
a process can receive <a href="https://manpages.ubuntu.com/manpages/bionic/en/man7/signal.7.html">signals</a>.
It can either react to them
in a default (OS-provided) way,
catch the signal and handle them in a program-defined way,
or ignore the signal entirely.</p>
<p>Windows does not have signals.
You can use <a href="https://docs.microsoft.com/en-us/windows/console/console-control-handlers">Console Handlers</a>
to define callbacks that get executed when an event occurs.
There is also <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/structured-exception-handling">structured exception handling</a>
which handles all the various types of system exceptions such as division by zero, invalid access exceptions, stack overflow, and so on</p>
<h2 id="first-off-handling-ctrlc"><a class="header" href="#first-off-handling-ctrlc">First off: Handling Ctrl+C</a></h2>
<p>The <a href="https://crates.io/crates/ctrlc">ctrlc</a> crate does just what the name suggests:
It allows you to react to the user pressing <kbd>Ctrl</kbd>+<kbd>C</kbd>,
in a cross-platform way.
The main way to use the crate is this:</p>
<pre><code class="language-rust ignore">use std::{thread, time::Duration};

fn main() {
    ctrlc::set_handler(move || {
        println!(&quot;received Ctrl+C!&quot;);
    })
    .expect(&quot;Error setting Ctrl-C handler&quot;);

    // Following code does the actual work, and can be interrupted by pressing
    // Ctrl-C. As an example: Let's wait a few seconds.
    thread::sleep(Duration::from_secs(2));
}
</code></pre>
<p>This is, of course, not that helpful:
It only prints a message but otherwise doesn’t stop the program.</p>
<p>In a real-world program,
it’s a good idea to instead set a variable in the signal handler
that you then check in various places in your program.
For example,
you can set an <code>Arc&lt;AtomicBool&gt;</code>
(a boolean shareable between threads)
in your signal handler,
and in hot loops,
or when waiting for a thread,
you periodically check its value
and break when it becomes true.</p>
<h2 id="handling-other-types-of-signals"><a class="header" href="#handling-other-types-of-signals">Handling other types of signals</a></h2>
<p>The <a href="https://crates.io/crates/ctrlc">ctrlc</a> crate only handles <kbd>Ctrl</kbd>+<kbd>C</kbd>,
or, what on Unix systems would be called <code>SIGINT</code> (the “interrupt” signal).
To react to more Unix signals,
you should have a look at <a href="https://crates.io/crates/signal-hook">signal-hook</a>.
Its design is described in <a href="https://vorner.github.io/2018/06/28/signal-hook.html">this blog post</a>,
and it is currently the library with the widest community support.</p>
<p>Here’s a simple example:</p>
<pre><code class="language-rust ignore">use signal_hook::{consts::SIGINT, iterator::Signals};
use std::{error::Error, thread, time::Duration};

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let mut signals = Signals::new(&amp;[SIGINT])?;

    thread::spawn(move || {
        for sig in signals.forever() {
            println!(&quot;Received signal {:?}&quot;, sig);
        }
    });

    // Following code does the actual work, and can be interrupted by pressing
    // Ctrl-C. As an example: Let's wait a few seconds.
    thread::sleep(Duration::from_secs(2));

    Ok(())
}
</code></pre>
<h2 id="using-channels"><a class="header" href="#using-channels">Using channels</a></h2>
<p>Instead of setting a variable
and having other parts of the program check it,
you can use channels:
You create a channel into which the signal handler emits a value
whenever the signal is received.
In your application code you use
this and other channels
as synchronization points between threads.
Using <a href="https://crates.io/crates/crossbeam-channel">crossbeam-channel</a> it would look something like this:</p>
<pre><code class="language-rust ignore">use std::time::Duration;
use crossbeam_channel::{bounded, tick, Receiver, select};
use anyhow::Result;

fn ctrl_channel() -&gt; Result&lt;Receiver&lt;()&gt;, ctrlc::Error&gt; {
    let (sender, receiver) = bounded(100);
    ctrlc::set_handler(move || {
        let _ = sender.send(());
    })?;

    Ok(receiver)
}

fn main() -&gt; Result&lt;()&gt; {
    let ctrl_c_events = ctrl_channel()?;
    let ticks = tick(Duration::from_secs(1));

    loop {
        select! {
            recv(ticks) -&gt; _ =&gt; {
                println!(&quot;working!&quot;);
            }
            recv(ctrl_c_events) -&gt; _ =&gt; {
                println!();
                println!(&quot;Goodbye!&quot;);
                break;
            }
        }
    }

    Ok(())
}
</code></pre>
<h2 id="using-futures-and-streams"><a class="header" href="#using-futures-and-streams">Using futures and streams</a></h2>
<p>If you are using <a href="https://tokio.rs/">tokio</a>,
you are most likely already writing your application
with asynchronous patterns and an event-driven design.
Instead of using crossbeam’s channels directly,
you can enable signal-hook’s <code>tokio-support</code> feature.
This allows you to call <a href="https://docs.rs/signal-hook/0.1.6/signal_hook/iterator/struct.Signals.html#method.into_async"><code>.into_async()</code></a>
on signal-hook’s <code>Signals</code> types
to get a new type that implements <code>futures::Stream</code>.</p>
<h2 id="what-to-do-when-you-receive-another-ctrlc-while-youre-handling-the-first-ctrlc"><a class="header" href="#what-to-do-when-you-receive-another-ctrlc-while-youre-handling-the-first-ctrlc">What to do when you receive another Ctrl+C while you’re handling the first Ctrl+C</a></h2>
<p>Most users will press <kbd>Ctrl</kbd>+<kbd>C</kbd>,
and then give your program a few seconds to exit,
or tell them what’s going on.
If that doesn’t happen,
they will press <kbd>Ctrl</kbd>+<kbd>C</kbd> again.
The typical behavior is to have the application quit immediately.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-config-files"><a class="header" href="#using-config-files">Using config files</a></h1>
<p>Dealing with configurations can be annoying
especially if you support multiple operating systems
which all have their own places
for short- and long-term files.</p>
<p>There are multiple solutions to this,
some being more low-level than others.</p>
<p>The easiest crate to use for this is <a href="https://docs.rs/confy/0.3.1/confy/"><code>confy</code></a>.
It asks you for the name of your application
and requires you to specify the config layout
via a <code>struct</code> (that is <code>Serialize</code>, <code>Deserialize</code>)
and it will figure out the rest!</p>
<pre><code class="language-rust ignore">#[derive(Debug, Serialize, Deserialize)]
struct MyConfig {
    name: String,
    comfy: bool,
    foo: i64,
}

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let cfg: MyConfig = confy::load(&quot;my_app&quot;)?;
    println!(&quot;{:#?}&quot;, cfg);
    Ok(())
}
</code></pre>
<p>This is incredibly easy to use
for which you of course surrender configurability.
But if a simple config is all you want,
this crate might be for you!</p>
<h2 id="configuration-environments"><a class="header" href="#configuration-environments">Configuration environments</a></h2>
<aside class="todo">
<p><strong>TODO</strong></p>
<ol>
<li>Evaluate crates that exist</li>
<li>Cli-args + multiple configs + env variables</li>
<li>Can <a href="https://docs.rs/configure/0.1.1/configure/"><code>configure</code></a> do all this? Is there a nice wrapper around it?</li>
</ol>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exit-codes"><a class="header" href="#exit-codes">Exit codes</a></h1>
<p>A program doesn’t always succeed.
And when an error occurs,
you should make sure to emit the necessary information correctly.
In addition to
<a href="in-depth/human-communication.html">telling the user about errors</a>,
on most systems,
when a process exits,
it also emits an exit code
(an integer between 0 and 255 is compatible with most platforms).
You should try to emit the correct code
for your program’s state.
For example,
in the ideal case when your program succeeds,
it should exit with <code>0</code>.</p>
<p>When an error occurs, it gets a bit more complicated, though.
In the wild,
many tools exit with <code>1</code> when a common failure occurs.
Currently, Rust sets an exit code of <code>101</code> when the process panicked.
Beyond that, people have done many things in their programs.</p>
<p>So, what to do?
The BSD ecosystem has collected a common definition for their exit codes
(you can find them <a href="https://www.freebsd.org/cgi/man.cgi?query=sysexits&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+11.2-stable&amp;arch=default&amp;format=html">here</a>).
The Rust library <a href="https://crates.io/crates/exitcode"><code>exitcode</code></a> provides these same codes,
ready to be used in your application.
Please see its API documentation for the possible values to use.</p>
<p>After you add the <code>exitcode</code> dependency to your <code>Cargo.toml</code>,
you can use it like this:</p>
<pre><code class="language-rust ignore">fn main() {
    // ...actual work...
    match result {
        Ok(_) =&gt; {
            println!(&quot;Done!&quot;);
            std::process::exit(exitcode::OK);
        }
        Err(CustomError::CantReadConfig(e)) =&gt; {
            eprintln!(&quot;Error: {}&quot;, e);
            std::process::exit(exitcode::CONFIG);
        }
        Err(e) =&gt; {
            eprintln!(&quot;Error: {}&quot;, e);
            std::process::exit(exitcode::DATAERR);
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communicating-with-humans"><a class="header" href="#communicating-with-humans">Communicating with humans</a></h1>
<p>Make sure to read <a href="in-depth/../tutorial/output.html">the chapter on CLI output</a>
in the tutorial first.
It covers how to write output to the terminal,
while this chapter will talk about <em>what</em> to output.</p>
<h2 id="when-everything-is-fine"><a class="header" href="#when-everything-is-fine">When everything is fine</a></h2>
<p>It is useful to report on the application’s progress
even when everything is fine.
Try to be informative and concise in these messages.
Don’t use overly technical terms in the logs.
Remember:
the application is not crashing
so there’s no reason for users to look up errors.</p>
<p>Most importantly,
be consistent in the style of communication.
Use the same prefixes and sentence structure
to make the logs easily skimmable.</p>
<p>Try to let your application output tell a story
about what it’s doing
and how it impacts the user.
This can involve showing a timeline of steps involved
or even a progress bar and indicator for long-running actions.
The user should at no point
get the feeling that the application is doing something mysterious
that they cannot follow.</p>
<h2 id="when-its-hard-to-tell-whats-going-on"><a class="header" href="#when-its-hard-to-tell-whats-going-on">When it’s hard to tell what’s going on</a></h2>
<p>When communicating non-nominal state it’s important to be consistent.
A heavily logging application that doesn’t follow strict logging levels
provides the same amount, or even less information
than a non-logging application.</p>
<p>Because of this,
it’s important to define the severity of events
and messages that are related to it;
then use consistent log levels for them.
This way users can select the amount of logging themselves
via <code>--verbose</code> flags
or environment variables (like <code>RUST_LOG</code>).</p>
<p>The commonly used <code>log</code> crate
<a href="https://docs.rs/log/0.4.4/log/enum.Level.html">defines</a> the following levels
(ordered by increasing severity):</p>
<ul>
<li>trace</li>
<li>debug</li>
<li>info</li>
<li>warning</li>
<li>error</li>
</ul>
<p>It’s a good idea to think of <em>info</em> as the default log level.
Use it for, well, informative output.
(Some applications that lean towards a more quiet output style
might only show warnings and errors by default.)</p>
<p>Additionally,
it’s always a good idea to use similar prefixes
and sentence structure across log messages,
making it easy to use a tool like <code>grep</code> to filter for them.
A message should provide enough context by itself
to be useful in a filtered log
while not being <em>too</em> verbose at the same time.</p>
<h3 id="example-log-statements"><a class="header" href="#example-log-statements">Example log statements</a></h3>
<pre><code class="language-console">error: could not find `Cargo.toml` in `/home/you/project/`
</code></pre>
<pre><code class="language-console">=&gt; Downloading repository index
=&gt; Downloading packages...
</code></pre>
<p>The following log output is taken from <a href="https://crates.io/crates/wasm-pack">wasm-pack</a>:</p>
<pre><code class="language-console"> [1/7] Adding WASM target...
 [2/7] Compiling to WASM...
 [3/7] Creating a pkg directory...
 [4/7] Writing a package.json...
 &gt; [WARN]: Field `description` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `repository` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `license` is missing from Cargo.toml. It is not necessary, but recommended
 [5/7] Copying over your README...
 &gt; [WARN]: origin crate has no README
 [6/7] Installing WASM-bindgen...
 &gt; [INFO]: wasm-bindgen already installed
 [7/7] Running WASM-bindgen...
 Done in 1 second
</code></pre>
<h2 id="when-panicking"><a class="header" href="#when-panicking">When panicking</a></h2>
<p>One aspect often forgotten is that
your program also outputs something when it crashes.
In Rust, “crashes” are most often “panics”
(i.e., “controlled crashing”
in contrast to “the operating system killed the process”).
By default,
when a panic occurs,
a “panic handler” will print some information to the console.</p>
<p>For example,
if you create a new binary project
with <code>cargo new --bin foo</code>
and replace the content of <code>fn main</code> with <code>panic!(&quot;Hello World&quot;)</code>,
you get this when you run your program:</p>
<pre><code class="language-console">thread 'main' panicked at 'Hello, world!', src/main.rs:2:5
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>This is useful information to you, the developer.
(Surprise: the program crashed because of line 2 in your <code>main.rs</code> file).
But for a user who doesn’t even have access to the source code,
this is not very valuable.
In fact, it most likely is just confusing.
That’s why it’s a good idea to add a custom panic handler,
that provides a bit more end-user focused output.</p>
<p>One library that does just that is called <a href="https://crates.io/crates/human-panic">human-panic</a>.
To add it to your CLI project,
you import it
and call the <code>setup_panic!()</code> macro
at the beginning of your <code>main</code> function:</p>
<pre><code class="language-rust ignore">use human_panic::setup_panic;

fn main() {
   setup_panic!();

   panic!(&quot;Hello world&quot;)
}
</code></pre>
<p>This will now show a very friendly message,
and tells the user what they can do:</p>
<pre><code class="language-console">Well, this is embarrassing.

foo had a problem and crashed. To help us diagnose the problem you can send us a crash report.

We have generated a report file at &quot;/var/folders/n3/dkk459k908lcmkzwcmq0tcv00000gn/T/report-738e1bec-5585-47a4-8158-f1f7227f0168.toml&quot;. Submit an issue or email with the subject of &quot;foo Crash Report&quot; and include the report as an attachment.

- Authors: Your Name &lt;your.name@example.com&gt;

We take privacy seriously, and do not perform any automated error collection. In order to improve the software, we rely on people to submit reports.

Thank you kindly!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communicating-with-machines"><a class="header" href="#communicating-with-machines">Communicating with machines</a></h1>
<p>The power of command-line tools really comes to shine
when you are able to combine them.
This is not a new idea:
In fact, this is a sentence from the <a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix philosophy</a>:</p>
<blockquote>
<p>Expect the output of every program to become the input to another, as yet unknown, program.</p>
</blockquote>
<p>If our programs fulfill this expectation,
our users will be happy.
To make sure this works well,
we should provide not just pretty output for humans,
but also a version tailored to what other programs need.
Let’s see how we can do this.</p>
<aside>
<p><strong>Aside:</strong>
Make sure to read <a href="in-depth/../tutorial/output.html">the chapter on CLI output</a>
in the tutorial first.
It covers how to write output to the terminal.</p>
</aside>
<h2 id="whos-reading-this"><a class="header" href="#whos-reading-this">Who’s reading this?</a></h2>
<p>The first question to ask is:
Is our output for a human in front of a colorful terminal,
or for another program?
To answer this,
we can use a crate like <a href="https://crates.io/crates/atty">atty</a>:</p>
<pre><code class="language-rust ignore">use atty::Stream;

if atty::is(Stream::Stdout) {
    println!(&quot;I'm a terminal&quot;);
} else {
    println!(&quot;I'm not&quot;);
}
</code></pre>
<p>Depending on who will read our output,
we can then add extra information.
Humans tend to like colors,
for example,
if you run <code>ls</code> in a random Rust project,
you might see something like this:</p>
<pre><code class="language-console">$ ls
CODE_OF_CONDUCT.md   LICENSE-APACHE       examples
CONTRIBUTING.md      LICENSE-MIT          proptest-regressions
Cargo.lock           README.md            src
Cargo.toml           convey_derive        target
</code></pre>
<p>Because this style is made for humans,
in most configurations
it’ll even print some of the names (like <code>src</code>) in color
to show that they are directories.
If you instead pipe this to a file,
or a program like <code>cat</code>,
<code>ls</code> will adapt its output.
Instead of using columns that fit my terminal window
it will print every entry on its own line.
It will also not emit any colors.</p>
<pre><code class="language-console">$ ls | cat
CODE_OF_CONDUCT.md
CONTRIBUTING.md
Cargo.lock
Cargo.toml
LICENSE-APACHE
LICENSE-MIT
README.md
convey_derive
examples
proptest-regressions
src
target
</code></pre>
<h2 id="easy-output-formats-for-machines"><a class="header" href="#easy-output-formats-for-machines">Easy output formats for machines</a></h2>
<p>Historically,
the only type of output command-line tools produced were strings.
This is usually fine for people in front of terminals,
who are able to read text
and reason about its meaning.
Other programs usually don’t have that ability, though:
The only way for them to understand the output of a tool
like <code>ls</code>
is if the author of the program included a parser
that happens to work for whatever <code>ls</code> outputs.</p>
<p>This often means
that output was limited to what is easy to parse.
Formats like TSV (tab-separated values),
where each record is on its own line,
and each line contains tab-separated content,
are very popular.
These simple formats based on lines of text
allow tools like <code>grep</code>
to be used on the output of tools like <code>ls</code>.
<code>| grep Cargo</code> doesn’t care if your lines are from <code>ls</code> or file,
it will just filter line by line.</p>
<p>The downside of this is that you can’t use
an easy <code>grep</code> invocation to filter all the directories that <code>ls</code> gave you.
For that, each directory item would need to carry additional data.</p>
<h2 id="json-output-for-machines"><a class="header" href="#json-output-for-machines">JSON output for machines</a></h2>
<p>Tab-separated values is a simple way
to output structured data
but it requires the other program to know which fields to expect
(and in which order)
and it’s difficult to output messages of different types.
For example,
let’s say our program wanted to message the consumer
that it is currently waiting for a download,
and afterwards output a message describing the data it got.
Those are very different kinds of messages
and trying to unify them in a TSV output
would require us to invent a way to differentiate them.
Same when we wanted to print a message that contains two lists
of items of varying lengths.</p>
<p>Still,
it’s a good idea to choose a format that is easily parsable
in most programming languages/environments.
Thus,
over the last years a lot of applications gained the ability
to output their data in <a href="https://www.json.org/">JSON</a>.
It’s simple enough that parsers exist in practically every language
yet powerful enough to be useful in a lot of cases.
While its a text format that can be read by humans,
a lot of people have also worked on implementations that are very fast at
parsing JSON data and serializing data to JSON.</p>
<p>In the description above,
we’ve talked about “messages” being written by our program.
This is a good way of thinking about the output:
Your program doesn’t necessarily only output one blob of data
but may in fact emit a lot of different information
while it is running.
One easy way to support this approach when outputting JSON
is to write one JSON document per message
and to put each JSON document on new line
(sometimes called <a href="https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON">Line-delimited JSON</a>).
This can make implementations as simple as using a regular <code>println!</code>.</p>
<p>Here’s a simple example,
using the <code>json!</code> macro from <a href="https://crates.io/crates/serde_json">serde_json</a>
to quickly write valid JSON in your Rust source code:</p>
<pre><code class="language-rust ignore">use clap::Parser;
use serde_json::json;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(Parser)]
struct Cli {
    /// Output JSON instead of human readable messages
    #[arg(long = &quot;json&quot;)]
    json: bool,
}

fn main() {
    let args = Cli::parse();
    if args.json {
        println!(
            &quot;{}&quot;,
            json!({
                &quot;type&quot;: &quot;message&quot;,
                &quot;content&quot;: &quot;Hello world&quot;,
            })
        );
    } else {
        println!(&quot;Hello world&quot;);
    }
}
</code></pre>
<p>And here is the output:</p>
<pre><code class="language-console">$ cargo run -q
Hello world
$ cargo run -q -- --json
{&quot;content&quot;:&quot;Hello world&quot;,&quot;type&quot;:&quot;message&quot;}
</code></pre>
<p>(Running <code>cargo</code> with <code>-q</code> suppresses its usual output.
The arguments after <code>--</code> are passed to our program.)</p>
<h3 id="practical-example-ripgrep"><a class="header" href="#practical-example-ripgrep">Practical example: ripgrep</a></h3>
<p><em><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a></em> is a replacement for <em>grep</em> or <em>ag</em>, written in Rust.
By default it will produce output like this:</p>
<pre><code class="language-console">$ rg default
src/lib.rs
37:    Output::default()

src/components/span.rs
6:    Span::default()
</code></pre>
<p>But given <code>--json</code> it will print:</p>
<pre><code class="language-console">$ rg default --json
{&quot;type&quot;:&quot;begin&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/lib.rs&quot;}}}
{&quot;type&quot;:&quot;match&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/lib.rs&quot;},&quot;lines&quot;:{&quot;text&quot;:&quot;    Output::default()\n&quot;},&quot;line_number&quot;:37,&quot;absolute_offset&quot;:761,&quot;submatches&quot;:[{&quot;match&quot;:{&quot;text&quot;:&quot;default&quot;},&quot;start&quot;:12,&quot;end&quot;:19}]}}
{&quot;type&quot;:&quot;end&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/lib.rs&quot;},&quot;binary_offset&quot;:null,&quot;stats&quot;:{&quot;elapsed&quot;:{&quot;secs&quot;:0,&quot;nanos&quot;:137622,&quot;human&quot;:&quot;0.000138s&quot;},&quot;searches&quot;:1,&quot;searches_with_match&quot;:1,&quot;bytes_searched&quot;:6064,&quot;bytes_printed&quot;:256,&quot;matched_lines&quot;:1,&quot;matches&quot;:1}}}
{&quot;type&quot;:&quot;begin&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/components/span.rs&quot;}}}
{&quot;type&quot;:&quot;match&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/components/span.rs&quot;},&quot;lines&quot;:{&quot;text&quot;:&quot;    Span::default()\n&quot;},&quot;line_number&quot;:6,&quot;absolute_offset&quot;:117,&quot;submatches&quot;:[{&quot;match&quot;:{&quot;text&quot;:&quot;default&quot;},&quot;start&quot;:10,&quot;end&quot;:17}]}}
{&quot;type&quot;:&quot;end&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/components/span.rs&quot;},&quot;binary_offset&quot;:null,&quot;stats&quot;:{&quot;elapsed&quot;:{&quot;secs&quot;:0,&quot;nanos&quot;:22025,&quot;human&quot;:&quot;0.000022s&quot;},&quot;searches&quot;:1,&quot;searches_with_match&quot;:1,&quot;bytes_searched&quot;:5221,&quot;bytes_printed&quot;:277,&quot;matched_lines&quot;:1,&quot;matches&quot;:1}}}
{&quot;data&quot;:{&quot;elapsed_total&quot;:{&quot;human&quot;:&quot;0.006995s&quot;,&quot;nanos&quot;:6994920,&quot;secs&quot;:0},&quot;stats&quot;:{&quot;bytes_printed&quot;:533,&quot;bytes_searched&quot;:11285,&quot;elapsed&quot;:{&quot;human&quot;:&quot;0.000160s&quot;,&quot;nanos&quot;:159647,&quot;secs&quot;:0},&quot;matched_lines&quot;:2,&quot;matches&quot;:2,&quot;searches&quot;:2,&quot;searches_with_match&quot;:2}},&quot;type&quot;:&quot;summary&quot;}
</code></pre>
<p>As you can see,
each JSON document is an object (map) containing a <code>type</code> field.
This would allow us to write a simple frontend for <code>rg</code>
that reads these documents as they come in and show the matches
(as well the files they are in)
even while <em>ripgrep</em> is still searching.</p>
<aside>
<p><strong>Aside:</strong>
This is how Visual Studio Code uses <em>ripgrep</em> for its code search.</p>
</aside>
<h2 id="how-to-deal-with-input-piped-into-us"><a class="header" href="#how-to-deal-with-input-piped-into-us">How to deal with input piped into us</a></h2>
<p>Let’s say we have a program that reads the number of words in a file:</p>
<pre><code class="language-rust ignore">use clap::Parser;
use std::path::PathBuf;

/// Count the number of lines in a file
#[derive(Parser)]
#[command(arg_required_else_help = true)]
struct Cli {
    /// The path to the file to read
    file: PathBuf,
}

fn main() {
    let args = Cli::parse();
    let mut word_count = 0;
    let file = args.file;

    for line in std::fs::read_to_string(&amp;file).unwrap().lines() {
        word_count += line.split(' ').count();
    }

    println!(&quot;Words in {}: {}&quot;, file.to_str().unwrap(), word_count)
}
</code></pre>
<p>It takes the path to a file, reads it line by line, and counts the number of
words separated by a space.</p>
<p>When you run it, it outputs the total words in the file:</p>
<pre><code class="language-console">$ cargo run README.md
Words in README.md: 47
</code></pre>
<p>But what if we wanted to count the number of words piped into the program?
Rust programs can read data passed in via stdin with the with <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html">the Stdin
struct</a> which you can
obtain via <a href="https://doc.rust-lang.org/std/io/fn.stdin.html">the stdin function</a>
from the standard library. Similar to reading the lines of a file, it can read
the lines from stdin.</p>
<p>Here’s a program that counts the words of what’s piped in via stdin</p>
<pre><code class="language-rust ignore">use clap::{CommandFactory, Parser};
use std::{io::{stdin, BufReader, BufRead}, path::PathBuf, fs::File};
use atty::Stream;

/// Count the number of lines in a file or stdin
#[derive(Parser)]
#[command(arg_required_else_help = true)]
struct Cli {
    /// The path to the file to read, use - to read from stdin (must not be a tty)
    file: PathBuf,
}

fn main() {
    let args = Cli::parse();

    let word_count;
    let mut file = args.file;

    if file == PathBuf::from(&quot;-&quot;) {
        if atty::is(Stream::Stdin) {
            Cli::command().print_help().unwrap();
            ::std::process::exit(2);
        }

        file = PathBuf::from(&quot;&lt;stdin&gt;&quot;);
        word_count = words_in_buf_reader(BufReader::new(stdin().lock()));
    } else {
        word_count = words_in_buf_reader(BufReader::new(File::open(&amp;file).unwrap()));
    }

    println!(&quot;Words from {}: {}&quot;, file.to_string_lossy(), word_count)
}

fn words_in_buf_reader&lt;R: BufRead&gt;(buf_reader: R) -&gt; usize {
    let mut count = 0;
    for line in buf_reader.lines() {
        count += line.unwrap().split(' ').count()
    }
    count
}
</code></pre>
<p>If you run that program with text piped in, with <code>-</code> representing the intent to
read from <code>stdin</code>, it’ll output the word count:</p>
<pre><code class="language-console">$ echo &quot;hi there friend&quot; | cargo run -- -
Words from stdin: 3
</code></pre>
<p>It requires that stdin is not interactive because we’re expecting input that’s
piped through to the program, not text that’s typed in at runtime. If stdin is
a tty, it outputs the help docs so that it’s clear why it doesn’t work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-documentation-for-your-cli-apps"><a class="header" href="#rendering-documentation-for-your-cli-apps">Rendering documentation for your CLI apps</a></h1>
<p>Documentation for CLIs usually consists of
a <code>--help</code> section in the command
and a manual (<code>man</code>) page.</p>
<p>Both can be automatically generated
when using <a href="https://crates.io/crates/clap"><code>clap</code></a>, via
<a href="https://crates.io/crates/clap_mangen"><code>clap_mangen</code></a> crate.</p>
<pre><code class="language-rust ignore">#[derive(Parser)]
pub struct Head {
    /// file to load
    pub file: PathBuf,
    /// how many lines to print
    #[arg(short = &quot;n&quot;, default_value = &quot;5&quot;)]
    pub count: usize,
}
</code></pre>
<p>Secondly, you need to use a <code>build.rs</code>
to generate the manual file at compile time
from the definition of your app
in code.</p>
<p>There are a few things to keep in mind
(such as how you want to package your binary)
but for now
we simply put the <code>man</code> file
next to our <code>src</code> folder.</p>
<pre><code class="language-rust ignore">use clap::CommandFactory;

#[path=&quot;src/cli.rs&quot;]
mod cli;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let out_dir = std::path::PathBuf::from(std::env::var_os(&quot;OUT_DIR&quot;).ok_or_else(|| std::io::ErrorKind::NotFound)?);
    let cmd = cli::Head::command();

    let man = clap_mangen::Man::new(cmd);
    let mut buffer: Vec&lt;u8&gt; = Default::default();
    man.render(&amp;mut buffer)?;

    std::fs::write(out_dir.join(&quot;head.1&quot;), buffer)?;

    Ok(())
}
</code></pre>
<p>When you now compile your application
there will be a <code>head.1</code> file
in your project directory.</p>
<p>If you open that in <code>man</code>
you’ll be able to admire your free documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<p>Collaboration / help</p>
<ul>
<li><a href="https://discord.com/channels/273534239310479360/943315667430563862">cli-and-tui Discord Channel</a></li>
</ul>
<h2 id="crates-referenced-in-this-book"><a class="header" href="#crates-referenced-in-this-book">Crates referenced in this book</a></h2>
<ul>
<li><a href="https://crates.io/crates/anyhow">anyhow</a> - provides <code>anyhow::Error</code> for easy error handling</li>
<li><a href="https://crates.io/crates/assert_cmd">assert_cmd</a> - simplifies integration testing of CLIs</li>
<li><a href="https://crates.io/crates/assert_fs">assert_fs</a> - Setup input files and test output files</li>
<li><a href="https://crates.io/crates/atty">atty</a> - detected whether application is running in a tty</li>
<li><a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a> - adds a <code>--verbose</code> flag to clap CLIs</li>
<li><a href="https://crates.io/crates/clap">clap</a> - command line argument parser</li>
<li><a href="https://crates.io/crates/confy">confy</a> - boilerplate-free configuration management</li>
<li><a href="https://crates.io/crates/crossbeam-channel">crossbeam-channel</a> - provides multi-producer multi-consumer channels for message passing</li>
<li><a href="https://crates.io/crates/ctrlc">ctrlc</a> - easy ctrl-c handler</li>
<li><a href="https://crates.io/crates/env_logger">env_logger</a> - implements a logger configurable via environment variables</li>
<li><a href="https://crates.io/crates/exitcode">exitcode</a> - system exit code constants</li>
<li><a href="https://crates.io/crates/human-panic">human-panic</a> - panic message handler</li>
<li><a href="https://crates.io/crates/indicatif">indicatif</a> - progress bars and spinners</li>
<li><a href="https://crates.io/crates/log">log</a> - provides logging abstracted over implementation</li>
<li><a href="https://crates.io/crates/predicates">predicates</a> - implements boolean-valued predicate functions</li>
<li><a href="https://crates.io/crates/proptest">proptest</a> - property testing framework</li>
<li><a href="https://crates.io/crates/serde_json">serde_json</a> - serialize/deserialize to JSON</li>
<li><a href="https://crates.io/crates/signal-hook">signal-hook</a> - handles UNIX signals</li>
<li><a href="https://crates.io/crates/tokio">tokio</a> - asynchronous runtime</li>
<li><a href="https://crates.io/crates/wasm-pack">wasm-pack</a> - tool for building WebAssembly</li>
</ul>
<h2 id="other-crates"><a class="header" href="#other-crates">Other crates</a></h2>
<p>Due to the constantly-changing landscape of Rust crates, a good place to find
crates is the <a href="https://lib.rs">lib.rs</a> crate index, including:</p>
<ul>
<li><a href="https://lib.rs/command-line-interface">Command-line interface</a></li>
<li><a href="https://lib.rs/config">Configuration</a></li>
<li><a href="https://lib.rs/database">Database interfaces</a></li>
<li><a href="https://lib.rs/encoding">Encoding</a></li>
<li><a href="https://lib.rs/filesystem">Filesystem</a></li>
<li><a href="https://lib.rs/web-programming/http-client">HTTP Client</a></li>
<li><a href="https://lib.rs/os">Operating systems</a></li>
</ul>
<p>Other resources:</p>
<ul>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust Cookbook</a></li>
<li><a href="https://github.com/rosetta-rs">rosetta-rs</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
